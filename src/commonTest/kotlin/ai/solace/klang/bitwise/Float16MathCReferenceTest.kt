package ai.solace.klang.bitwise

import kotlin.test.Test
import kotlin.test.assertEquals

/**
 * Float16MathCReferenceTest - Validates Kotlin Float16Math against C reference implementation.
 * 
 * These test vectors are generated by tools/float16_spotcheck.c
 * The Kotlin implementation should match the C implementation bit-for-bit.
 * 
 * This ensures C-alignment (compiler-rt compatibility) across all platforms.
 */
class Float16MathCReferenceTest {
    
    /**
     * Test vectors from tools/float16_spotcheck.c output:
     * 
     * Test 0: a=1.000 (0x3C00) b=1.000 (0x3C00)
     *   add=0x4000 sub=0x0000 mul=0x3C00 div=0x3C00
     */
    @Test
    fun testCase0_OnesPlusOne() {
        val a = 0x3C00  // 1.0
        val b = 0x3C00  // 1.0
        
        val add = Float16Math.addBits(a, b)
        val sub = Float16Math.subBits(a, b)
        val mul = Float16Math.mulBits(a, b)
        val div = Float16Math.divBits(a, b)
        
        assertEquals(0x4000, add and 0xFFFF, "1.0 + 1.0 should be 0x4000")
        assertEquals(0x0000, sub and 0xFFFF, "1.0 - 1.0 should be 0x0000")
        assertEquals(0x3C00, mul and 0xFFFF, "1.0 * 1.0 should be 0x3C00")
        assertEquals(0x3C00, div and 0xFFFF, "1.0 / 1.0 should be 0x3C00")
    }
    
    /**
     * Test 1: a=2.500 (0x4100) b=3.500 (0x4300)
     *   add=0x4600 sub=0xBC00 mul=0x4860 div=0x39B7
     */
    @Test
    fun testCase1_TwoPointFiveAndThreePointFive() {
        val a = 0x4100  // 2.5
        val b = 0x4300  // 3.5
        
        val add = Float16Math.addBits(a, b)
        val sub = Float16Math.subBits(a, b)
        val mul = Float16Math.mulBits(a, b)
        val div = Float16Math.divBits(a, b)
        
        assertEquals(0x4600, add and 0xFFFF, "2.5 + 3.5 should be 0x4600")
        assertEquals(0xBC00, sub and 0xFFFF, "2.5 - 3.5 should be 0xBC00")
        assertEquals(0x4860, mul and 0xFFFF, "2.5 * 3.5 should be 0x4860")
        assertEquals(0x39B7, div and 0xFFFF, "2.5 / 3.5 should be 0x39B7")
    }
    
    /**
     * Test 2: a=5.000 (0x4500) b=3.000 (0x4200)
     *   add=0x4800 sub=0x4000 mul=0x4B80 div=0x3EAB
     */
    @Test
    fun testCase2_FiveAndThree() {
        val a = 0x4500  // 5.0
        val b = 0x4200  // 3.0
        
        val add = Float16Math.addBits(a, b)
        val sub = Float16Math.subBits(a, b)
        val mul = Float16Math.mulBits(a, b)
        val div = Float16Math.divBits(a, b)
        
        assertEquals(0x4800, add and 0xFFFF, "5.0 + 3.0 should be 0x4800")
        assertEquals(0x4000, sub and 0xFFFF, "5.0 - 3.0 should be 0x4000")
        assertEquals(0x4B80, mul and 0xFFFF, "5.0 * 3.0 should be 0x4B80")
        assertEquals(0x3EAB, div and 0xFFFF, "5.0 / 3.0 should be 0x3EAB")
    }
    
    /**
     * Test 3: a=2.000 (0x4000) b=3.000 (0x4200)
     *   add=0x4500 sub=0xBC00 mul=0x4600 div=0x3955
     */
    @Test
    fun testCase3_TwoAndThree() {
        val a = 0x4000  // 2.0
        val b = 0x4200  // 3.0
        
        val add = Float16Math.addBits(a, b)
        val sub = Float16Math.subBits(a, b)
        val mul = Float16Math.mulBits(a, b)
        val div = Float16Math.divBits(a, b)
        
        assertEquals(0x4500, add and 0xFFFF, "2.0 + 3.0 should be 0x4500")
        assertEquals(0xBC00, sub and 0xFFFF, "2.0 - 3.0 should be 0xBC00")
        assertEquals(0x4600, mul and 0xFFFF, "2.0 * 3.0 should be 0x4600")
        assertEquals(0x3955, div and 0xFFFF, "2.0 / 3.0 should be 0x3955")
    }
    
    /**
     * Test 4: a=6.000 (0x4600) b=2.000 (0x4000)
     *   add=0x4800 sub=0x4400 mul=0x4A00 div=0x4200
     */
    @Test
    fun testCase4_SixAndTwo() {
        val a = 0x4600  // 6.0
        val b = 0x4000  // 2.0
        
        val add = Float16Math.addBits(a, b)
        val sub = Float16Math.subBits(a, b)
        val mul = Float16Math.mulBits(a, b)
        val div = Float16Math.divBits(a, b)
        
        assertEquals(0x4800, add and 0xFFFF, "6.0 + 2.0 should be 0x4800")
        assertEquals(0x4400, sub and 0xFFFF, "6.0 - 2.0 should be 0x4400")
        assertEquals(0x4A00, mul and 0xFFFF, "6.0 * 2.0 should be 0x4A00")
        assertEquals(0x4200, div and 0xFFFF, "6.0 / 2.0 should be 0x4200")
    }
    
    /**
     * Test 5: a=-1.500 (0xBE00) b=2.500 (0x4100)
     *   add=0x3C00 sub=0xC400 mul=0xC380 div=0xB8CD
     */
    @Test
    fun testCase5_NegativeOnePointFiveAndTwoPointFive() {
        val a = 0xBE00  // -1.5
        val b = 0x4100  // 2.5
        
        val add = Float16Math.addBits(a, b)
        val sub = Float16Math.subBits(a, b)
        val mul = Float16Math.mulBits(a, b)
        val div = Float16Math.divBits(a, b)
        
        assertEquals(0x3C00, add and 0xFFFF, "-1.5 + 2.5 should be 0x3C00")
        assertEquals(0xC400, sub and 0xFFFF, "-1.5 - 2.5 should be 0xC400")
        assertEquals(0xC380, mul and 0xFFFF, "-1.5 * 2.5 should be 0xC380")
        assertEquals(0xB8CD, div and 0xFFFF, "-1.5 / 2.5 should be 0xB8CD")
    }
}
